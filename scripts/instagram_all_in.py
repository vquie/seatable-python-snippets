"""
This script is used to configure and interact with Seatable API for ChatGPT.
It requires the `seatable-api` package to be installed.
"""

__author__ = "Vitali Quiering"
__version__ = "1.0.0-alpha"

import base64
import datetime
import json
import os
import random
import requests
import string
import urllib.parse
from seatable_api import Base, context

# Configuration variables
config_table = "_settings"
image_column = "Image"
google_vision_labels_column = "Google Vision API Labels"
chatgpt_dalle_prompt_column = "Image Prompt for DALL-E"
chatgpt_output_caption_column = "ChatGPT Generated Description"

# Retrieve server URL and API token from the context
server_url = context.server_url
api_token = context.api_token

# Initialize the Seatable API client
base = Base(api_token, server_url)
base.auth()

# Retrieve the current row and table name from the context
table_name = context.current_table

def get_config_values(config_table):
    """
    Retrieve the values in a config table.

    Args:
        config_table (str): Name of the config table.

    Returns:
        A dictionary mapping config keys to their values.
    """
    # Get the rows in the config table
    rows = base.list_rows(config_table)

    # Create a dictionary to store the config values
    config_dict = {}

    # Iterate over the rows and add the non-empty 'value' fields to the dictionary
    for row in rows:
        if "value" in row and row["value"]:
            config_dict[row["Name"]] = row["value"]

    return config_dict


def check_config_table(config_table):
    """
    Check if a config table exists, and create it if it does not.

    Args:
        config_table (str): Name of the table to check.

    Returns:
        None
    """
    # Get the metadata for the database
    base_metadata = base.get_metadata()

    # Check if the config table exists
    config_table_found = any(
        table["name"] == config_table for table in base_metadata["tables"]
    )

    # If the config table does not exist, exit with an error message
    if not config_table_found:
        raise SystemExit("Config table not found!")

def call_chatgpt_for_init_prompt():

    # Get the current date
    current_date = datetime.datetime.now().date()

    # Format the date as string
    formatted_date = current_date.strftime("%d %B %Y")  # Change the format as needed

    # Replace the {date} placeholder with the actual date
    chatgpt_role = f"please come up with a random sentence that fits today's date, {formatted_date}. Please keep it under 60 words."

    data = {
        "messages": [
            {"role": "system", "content": chatgpt_role},
        ],
        "model": "gpt-3.5-turbo",
        "max_tokens": 1000,
        "temperature": 0.9,
        "n": 1
    }

    generated_text = call_chatgpt(data)

    return generated_text

def call_chatgpt_for_caption(dalle_prompt, google_vision_labels):

    chatgpt_role = "As an automated system, generate Instagram posts for a fictitious dummy account. Create visually captivating posts with random images to produce semi-automatic content. Craft captions that are lighthearted and playful, reflecting the whimsical nature of the account. Utilize the additional information provided alongside the image to create unique and entertaining captions. Incorporate the labels generated by the Google Vision API as inspiration, while maintaining a light and non-serious tone. Generate the entire caption, including relevant hashtags, while avoiding the use of specific words that may imply the automated nature of the process. Keep the captions concise, within a limit of 150 words, and feel free to use new lines and emojis to add an element of fun to the content."

    data = {
        "messages": [
            {"role": "system", "content": chatgpt_role},
            {"role": "user", "content": f"Please mind this dall-e promt that was used for the image generation, refine and improve them for your task: {dalle_prompt}\n"}, 
            {"role": "user", "content": f"Google Vision Labels: {google_vision_labels}\n"},
        ],
        "model": "gpt-3.5-turbo",
        "max_tokens": 1000,
        "temperature": 0.9,
        "n": 1
    }

    generated_text = call_chatgpt(data)

    return generated_text

import requests

import requests

def call_chatgpt(data):
    """
    Call the ChatGPT API to generate a response based on the provided input.

    Args:
        chatgpt_role (str): The role for the AI in the conversation.
        chatgpt_vision_labels (str): Google Vision labels for the input.
        chatgpt_additional_notes (str): Additional notes for the AI.

    Returns:
        The generated text response from ChatGPT.
    """
    url = "https://api.openai.com/v1/chat/completions"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {openai_api_key}"
    }

    try:
        response = requests.post(url, headers=headers, json=data)
        generated_text = response.json()["choices"][0]["message"]["content"]
        return generated_text
    except Exception as e:
        print(f"Error: {e}")
        return None


def generate_dalle_image(dalle_prompt):

    # Generate the image using the call_dalle function
    generated_image_url = get_dalle_url(dalle_prompt)

    generated_image = requests.get(generated_image_url)

    # Generate a random 8-character string
    random_str = ''.join(random.choices(string.ascii_letters + string.digits, k=8))

    # Add file suffix
    random_str += ".png"

    uploaded_url = base.upload_bytes_file(content=generated_image.content, name=random_str, file_type='image', replace=True)

    img_url = uploaded_url.get('url')

    return img_url

def get_dalle_url(dalle_prompt):
    """
    Call the DALL-E API to generate an image based on the provided input.

    Args:
        dalle_prompt (str): The prompt for the DALL-E image generation.

    Returns:
        str: The URL of the generated image.
    """
    url = "https://api.openai.com/v1/images/generations"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {openai_api_key}"
    }
    data = {
        "prompt": f"{dalle_prompt}",
        "size": "1024x1024",
        "n": 1
    }
    response = requests.post(url, headers=headers, json=data)
    generated_image_url = response.json()["data"][0]["url"]
    return generated_image_url


def download_image(image_url):
    """
    Download an image from the specified URL and return its Base64-encoded content.

    This function downloads an image from the given URL and saves it to the local file system.
    It then reads the content of the image file, encodes it as Base64, and returns the Base64-encoded content.

    Args:
        image_url (str): URL of the image to download.

    Returns:
        str: Base64-encoded content of the downloaded image.
    """
    # Extract the filename from the image URL
    image_path = os.path.basename(urllib.parse.urlparse(image_url).path)

    # Download the image file
    base.download_file(image_url, image_path)

    # Read the image file
    with open(image_path, "rb") as image_file:
        image_content = image_file.read()

    # Encode the image content as Base64
    encoded_image_content = base64.b64encode(image_content).decode("utf-8")

    return encoded_image_content

def google_vision_process(encoded_image):
    """
    Process the labels of an image using the Google Vision API.

    This function sends a request to the Google Vision API to obtain labels for the specified image,
    based on its Base64-encoded content.
    It returns a list of tuples, where each tuple contains the label description and the label score.

    Args:
        encoded_image (str): Base64-encoded content of the image.

    Returns:
        list: A list of tuples containing label descriptions and scores.
    """

    os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = google_vision_application_credentials

    google_vision_payload = {
        "requests": [
            {
                "image": {"content": encoded_image},
                "features": [{"type": "LABEL_DETECTION"}],
            }
        ]
    }

    # Make the API request
    api_url = "https://vision.googleapis.com/v1/images:annotate?key=" + google_vision_api_key
    response = requests.post(api_url, json=google_vision_payload)

    # Parse the response
    response_json = response.json()

    # Extract and print the labels
    if "responses" in response_json and len(response_json["responses"]) > 0:
        labels = response_json["responses"][0].get("labelAnnotations", [])
        label_results = []
        for label in labels:
            label_description = label["description"]
            label_score = label["score"]
            label_results.append((label_description, label_score))
        return label_results
    else:
        print("Label detection failed.")
        exit()

def process_google_vision(dalle_image_url):

    encoded_image = download_image(dalle_image_url)

    labels = google_vision_process(encoded_image)

    return str(labels)



def main():
    """
    The main function that executes the ChatGPT generation process.

    Returns:
        None
    """

    dalle_prompt = call_chatgpt_for_init_prompt()

    dalle_image_url = generate_dalle_image(dalle_prompt)

    google_vision_labels = process_google_vision(dalle_image_url)

    chatgpt_image_caption = call_chatgpt_for_caption(dalle_prompt, google_vision_labels)

    row_data = {
        chatgpt_dalle_prompt_column: dalle_prompt,
        image_column: [dalle_image_url],
        google_vision_labels_column: google_vision_labels,
        chatgpt_output_caption_column: chatgpt_image_caption
    }

    base.append_row(table_name, row_data)


if __name__ == "__main__":
    # Check if the config table exists
    check_config_table(config_table)
    
    # Retrieve config values and update the local scope
    config_values = get_config_values(config_table)
    locals().update(config_values)

    # Call the main function
    main()

    # Terminate the script execution
    exit()
